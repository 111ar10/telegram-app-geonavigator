<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Compass Navigator</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <!-- Leaflet CSS -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css"/>
  <style>
    body {
      margin: 0;
      font-family: sans-serif;
      display: flex;
      flex-direction: column;
      height: 100vh;
      background: #000;
      color: #fff;
    }
    #compass {
      flex: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      font-size: 2em;
    }
    #distance {
      margin-top: 10px;
      font-size: 1.5em;
      font-weight: bold;
      color: #fff;
      background: rgba(0, 0, 0, 0.85);
      padding: 6px 12px;
      border-radius: 8px;
      text-align: center;
      box-shadow: 0 0 6px rgba(255,255,255,0.3);
    }
    #map {
      height: 40%;
    }
    .arrow {
      font-size: 5em;
      transition: transform 0.2s linear;
    }
    #modeToggle {
      margin: 8px;
      padding: 6px 12px;
      border: none;
      border-radius: 6px;
      background: #fff;
      color: #000;
      font-size: 1em;
      font-weight: bold;
    }
  </style>
</head>
<body>
  <div id="compass">
    <span id="arrow" class="arrow">ðŸ§­</span>
    <div id="distance">Waiting for GPS...</div>
    <button id="modeToggle">Mode: Compass</button>
  </div>
  <div id="map"></div>

  <!-- Leaflet JS -->
  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
  <script>
    // --- Get target from URL ---
    const urlParams = new URLSearchParams(window.location.search);
    const targetLat = parseFloat(urlParams.get("lat"));
    const targetLon = parseFloat(urlParams.get("lon"));

    // --- Leaflet map setup ---
    const map = L.map('map').setView([targetLat, targetLon], 15);

    L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
      maxZoom: 19
    }).addTo(map);

    // Marker for target
    const targetMarker = L.marker([targetLat, targetLon]).addTo(map).bindPopup("Target");

    // Marker for player
    let playerMarker = L.marker([0,0]).addTo(map).bindPopup("You are here");

    // --- Compass + Distance UI ---
    const arrow = document.getElementById("arrow");
    const distanceDiv = document.getElementById("distance");
    const modeToggle = document.getElementById("modeToggle");

    let mode = "compass"; // "compass" or "gps"

    modeToggle.addEventListener("click", () => {
      mode = (mode === "compass") ? "gps" : "compass";
      modeToggle.innerText = `Mode: ${mode === "compass" ? "Compass" : "GPS"}`;
    });

    // Bearing calculation
    function bearing(lat1, lon1, lat2, lon2) {
      const toRad = x => x * Math.PI / 180;
      const toDeg = x => x * 180 / Math.PI;
      const dLon = toRad(lon2 - lon1);
      lat1 = toRad(lat1);
      lat2 = toRad(lat2);

      const y = Math.sin(dLon) * Math.cos(lat2);
      const x = Math.cos(lat1)*Math.sin(lat2) - Math.sin(lat1)*Math.cos(lat2)*Math.cos(dLon);
      return (toDeg(Math.atan2(y, x)) + 360) % 360;
    }

    // Distance calculation (Haversine)
    function distance(lat1, lon1, lat2, lon2) {
      const R = 6371000; // meters
      const toRad = x => x * Math.PI / 180;
      const dLat = toRad(lat2 - lat1);
      const dLon = toRad(lon2 - lon1);
      lat1 = toRad(lat1);
      lat2 = toRad(lat2);

      const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                Math.cos(lat1) * Math.cos(lat2) *
                Math.sin(dLon/2) * Math.sin(dLon/2);
      const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
      return R * c; // meters
    }

    // Device heading (works on iOS + Android, smoothed)
    let deviceHeading = 0;
    let headingHistory = [];

    function smoothHeading(newHeading) {
      headingHistory.push(newHeading);
      if (headingHistory.length > 5) headingHistory.shift();
      const sum = headingHistory.reduce((a,b) => a+b, 0);
      return sum / headingHistory.length;
    }

    window.addEventListener("deviceorientationabsolute", e => {
      if (e.alpha !== null) {
        deviceHeading = smoothHeading(e.alpha);
      }
    }, true);

    window.addEventListener("deviceorientation", e => {
      if (e.webkitCompassHeading) {
        deviceHeading = smoothHeading(e.webkitCompassHeading); // iOS
      } else if (e.alpha !== null) {
        deviceHeading = smoothHeading(e.alpha); // Android
      }
    }, true);

    // Last GPS fix for GPS-bearing mode
    let lastLat = null, lastLon = null;

    // Track position
    navigator.geolocation.watchPosition(pos => {
      const lat = pos.coords.latitude;
      const lon = pos.coords.longitude;

      // Update player marker
      playerMarker.setLatLng([lat, lon]);
      map.setView([lat, lon]);

      // Bearing to target
      const brng = bearing(lat, lon, targetLat, targetLon);

      let angle;
      if (mode === "compass") {
        // Normalize with device compass
        angle = (brng - deviceHeading + 360) % 360;
      } else {
        // Use movement-based GPS bearing if last fix exists
        if (lastLat !== null && lastLon !== null) {
          angle = bearing(lastLat, lastLon, lat, lon);
        } else {
          angle = brng; // fallback
        }
      }

      arrow.style.transform = `rotate(${angle}deg)`;

      // Distance
      const dist = distance(lat, lon, targetLat, targetLon);
      if (dist > 1000) {
        distanceDiv.innerText = `Distance: ${(dist/1000).toFixed(2)} km`;
      } else {
        distanceDiv.innerText = `Distance: ${Math.round(dist)} m`;
      }

      lastLat = lat;
      lastLon = lon;
    }, err => {
      console.error(err);
      distanceDiv.innerText = "GPS error: unable to get location";
    }, { enableHighAccuracy: true });
  </script>
</body>
</html>
